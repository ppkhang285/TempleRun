-- MapGenerator.lua
-- import  
local Utils = require("GameUtils")
local Queue = require("Queue")
local SegmentRule = require("SegmentRule")
local List = require("List")
--
local UE = CS.UnityEngine


-- Init
local MapGenerator = {}
MapGenerator.__index = MapGenerator

function MapGenerator:new(spawnConfigData)
    local o = {}
    setmetatable(o, self)
    o:Initialize(spawnConfigData)

    return o
end


-- METHODS
function  MapGenerator:Initialize(spawnConfigData)
    self.spawnConfigData = spawnConfigData
    self:LoadDifficultData()
    self:HandleBiomeDict()
    --
    self.currentSegmentQ = Queue:new()
    self.currentBiome = self.spawnConfigData.startBiome
    self.segmentRule = SegmentRule:new()
    --
    self.MAX_SEGMENT = 11
    --

    self:AddSegment(Utils.Enums.SegmentType.START)

end


function MapGenerator:LoadDifficultData()
    self.difficultData = UE.Resources.Load(Utils.Paths.DIFFICULTY_DATA)
    if self.difficultData == nil then
        UE.Debug.Log("Cannot load DifficultData:  DifficultData is null")
    end

    UE.Debug.Log("Load DifficultData successfully");
end



function  MapGenerator:HandleBiomeDict()
    local dict = self.spawnConfigData:GetBiomeDataDict()
    self.biomeDataDict = Utils.UtilMethods.CSDictToTable(dict)

end

function MapGenerator:GetCurrentBiome()
    return self.currentBiome
end

function MapGenerator:GenerateNewSegmentType()

    local nextSegmentType = self:ProceduralGenerate()

    self:AddSegment(nextSegmentType)
    return nextSegmentType
end

function MapGenerator:ProceduralGenerate()
    local segmentList = List:new()
    local biomeData = self.biomeDataDict[self.currentBiome]

    for i = 0, biomeData.segmentTypeList.Count -1  do
        segmentList:Add(biomeData.segmentTypeList[i].segmentType)
    end

    segmentList = self.segmentRule:Filter(segmentList, self.currentSegmentQ:ToList())

    local nexSegmentType =  self:GetRandomType(segmentList)
    return nexSegmentType

end

function MapGenerator:GetRandomType(segmentList)
    local weightSum = 0
    local biomeProfile
    for i = 0, self.difficultData.profiles.Count -1 do
        if self.difficultData.profiles[i].profile.difficulty ==GameplayManager.currentDificulty then
            biomeProfile = self.difficultData.profiles[i].profile
        end
    end

    
    local segmentWeightDict = biomeProfile:GetSegmentWeightDict()
    segmentWeightDict = Utils.UtilMethods.CSDictToTable(segmentWeightDict)
    
    for i = 1, segmentList:Size() do
        weightSum = weightSum + segmentWeightDict[segmentList[i]]
    end

    local randomIndex = UE.Random.Range(0, weightSum)
    for i = 1, segmentList:Size() do
        randomIndex = randomIndex -  segmentWeightDict[segmentList[i]]
        if randomIndex <= 0 then
            return segmentList[i]
        end
    end

    return Utils.Enums.SegmentType.NONE
end







function MapGenerator:AddSegment(segmentType)
    if self.currentSegmentQ:Size() > self.MAX_SEGMENT then
        self:DeleteOldSegment()
    end
    self.currentSegmentQ:Enqueue(segmentType)

end


function MapGenerator:DeleteOldSegment()
    self.currentSegmentQ:Dequeue()
end

function MapGenerator:Reset()
    self.currentSegmentQ:Clear()

    self.currentBiome = self.spawnConfigData.startBiome
    self:AddSegment(Utils.Enums.segmentType.START)
end

-- Export

return MapGenerator